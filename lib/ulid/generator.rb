require 'sysrandom'

module ULID
  module Generator
    ENCODING = '0123456789ABCDEFGHJKMNPQRSTVWXYZ'.freeze # Crockford's Base32
    DECODING = [
      0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
      0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
      0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
      0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
      0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x01,
      0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0xFF, 0xFF,
      0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E,
      0x0F, 0x10, 0x11, 0x01, 0x12, 0x13, 0x01, 0x14, 0x15, 0x00,
      0x16, 0x17, 0x18, 0x19, 0x1A, 0xFF, 0x1B, 0x1C, 0x1D, 0x1E,
      0x1F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x0A, 0x0B, 0x0C,
      0x0D, 0x0E, 0x0F, 0x10, 0x11, 0x01, 0x12, 0x13, 0x01, 0x14,
      0x15, 0x00, 0x16, 0x17, 0x18, 0x19, 0x1A, 0xFF, 0x1B, 0x1C,
      0x1D, 0x1E, 0x1F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
      0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
      0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
      0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
      0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
      0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
      0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
      0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
      0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
      0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
      0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
      0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
      0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
      0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF ]
    RANDOM_BYTES = 10
    ENCODED_LENGTH = 26
    BIT_LENGTH = 128
    BITS_PER_B32_CHAR = 5
    REGEXP = Regexp.new("\\A[#{ENCODING}]{#{ENCODED_LENGTH}}\\z")
    MASK = 0x1f

    def generate(time = Time.now)
      input = generate_bytes(time)
      encode(input)
    end

    def generate_bytes(time = Time.now)
      time_48bit(time) + random_bytes
    end

    def encode(bytes)
      n = octo_word(bytes)
      e = '0' * ENCODED_LENGTH
      i = ENCODED_LENGTH - 1

      while n > 0
        e[i] = ENCODING[n & MASK]
        n >>= BITS_PER_B32_CHAR
        i -= 1
      end

      e
    end

    def decode(ulid)
      raise ArgumentError, 'Not a ULID' unless REGEXP =~ ulid
      bytes = ulid.bytes
      decoded = [
        ((DECODING[bytes[0]] << 5) | DECODING[bytes[1]]) & 0xFF,
        ((DECODING[bytes[2]] << 3) | (DECODING[bytes[3]] >> 2)) & 0xFF,
        ((DECODING[bytes[3]] << 6) | (DECODING[bytes[4]] << 1) | (DECODING[bytes[5]] >> 4)) & 0xFF,
        ((DECODING[bytes[5]] << 4) | (DECODING[bytes[6]] >> 1)) & 0xFF,
        ((DECODING[bytes[6]] << 7) | (DECODING[bytes[7]] << 2) | (DECODING[bytes[8]] >> 3)) & 0xFF,
        ((DECODING[bytes[8]] << 5) | (DECODING[bytes[9]])) & 0xFF,
        ((DECODING[bytes[10]] << 3) | (DECODING[bytes[11]] >> 2)) & 0xFF,
        ((DECODING[bytes[11]] << 6) | (DECODING[bytes[12]] << 1) | (DECODING[bytes[13]] >> 4)) & 0xFF,
        ((DECODING[bytes[13]] << 4) | (DECODING[bytes[14]] >> 1)) & 0xFF,
        ((DECODING[bytes[14]] << 7) | (DECODING[bytes[15]] << 2) | (DECODING[bytes[16]] >> 3)) & 0xFF,
        ((DECODING[bytes[16]] << 5) | (DECODING[bytes[17]])) & 0xFF,
        ((DECODING[bytes[18]] << 3) | (DECODING[bytes[19]] >> 2)) & 0xFF,
        ((DECODING[bytes[19]] << 6) | (DECODING[bytes[20]] << 1) | (DECODING[bytes[21]] >> 4)) & 0xFF,
        ((DECODING[bytes[21]] << 4) | (DECODING[bytes[22]] >> 1)) & 0xFF,
        ((DECODING[bytes[22]] << 7) | (DECODING[bytes[23]] << 2) | (DECODING[bytes[24]] >> 3)) & 0xFF,
        ((DECODING[bytes[24]] << 5) | (DECODING[bytes[25]])) & 0xFF
      ]

      decoded.pack('c*')
    end

    private

    def octo_word(bytes)
      (hi, lo) = bytes.unpack('Q>Q>')
      (hi << 64) | lo
    end

    def time_48bit(time = Time.now)
      time_ms = (time.to_f * 1000).to_i
      [time_ms].pack('Q>')[2..-1]
    end

    def random_bytes
      Sysrandom.random_bytes(RANDOM_BYTES)
    end
  end
end
